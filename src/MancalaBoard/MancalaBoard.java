package MancalaBoard;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * A mancala 'board' consists of a number of 'slots'. These slots hold a
 * number of 'beads' between zero and some maximum amount. This maximum
 * amount is called the 'ceiling'.  If the number of beads in a slot
 * exceeds the ceiling, the extra beads will 'spill' over into the next
 * available slot.
 */
public class MancalaBoard {

    final private List<Integer> m_board; // Immutable, as well
    final private int m_ceiling;

    /**
     * Creates the first mancala board of the sequence with the given
     * specifications.  The leftmost slot is filled to capacity first, then
     * the second leftmost, and so on.
     *
     * @param numSlots the number of slots that the beads may reside in
     * @param ceiling the maximum number of beads that may reside in a slot
     * @param numBeads the number of beads to distribute
     */
    public MancalaBoard(int numSlots, int ceiling, int numBeads) {
        ArrayList<Integer> board = new ArrayList<Integer>();
        for (int i=0; i < numSlots; i++) {     // Set up with empty slots
            board.add(0);
        }
        int index = 0;
        for (int i=0; i < numBeads; i++) {     // Fill the slots!
            if (board.get(index) >= ceiling) { // Spill condition
                index++;
                if (index >= numSlots)
                    throw new IllegalArgumentException("Too many beads.");
            }
            board.set(index, board.get(index) + 1);
        }
        m_board = Collections.unmodifiableList(board);
        m_ceiling = ceiling;
    }

    /**
     * Wraps the given board representation with MancalaBoard.MancalaBoard
     * functionality.  For private use only. The new internal representation
     * is generated within generateNext(), where this constructor is used.
     *
     * @param board
     * @param ceiling
     */
    private MancalaBoard(ArrayList<Integer> board, int ceiling) {
        this.m_ceiling = ceiling;
        m_board = Collections.unmodifiableList(board);
    }



    /**
     * Returns the next board in the mancala sequence, or null if the
     * sequence has ended.
     *
     * @return next board in sequence
     */
    public MancalaBoard generateNext() {
        ArrayList<Integer> nextBoard = copyOfBoard();

        /* This doesn't change; used throughout as shorthand */
        final int lastPos = nextBoard.size() - 1;

        /* The algorithm often involves 'lifting' beads up to move them around.
           This var represents the number of beads currently lifted.  By the
           time we return, lifted should be empty so that we aren't losing any
           beads.
         */
        int lifted = nextBoard.get(lastPos);
        nextBoard.set(lastPos, 0);

        /* If the next valid state is generated by simply moving one bead to the
           right (the common case), then this loop will only execute once.
           Each time that beads spill off the end of the board, the loop will be
           executed once more. (Usually no more than once per method call.)
         */
        int pos = findLastBead(nextBoard);
        while (pos != -1) {

            /* Move the furthest-right bead over by one, then drop the lifted
               beads on that last bead.

               Incrementing pos should not put it past the end of the list,
               since we lifted all beads out of board[-1] first.
             */
            nextBoard.set(pos, nextBoard.get(pos) - 1);
            pos++;
            nextBoard.set(pos, nextBoard.get(pos) + 1 + lifted);
            lifted = 0;

            /* If the number of beads in a slot exceeds the ceiling, beads
               must spill over into the next slot.  We also need to detect
               when we spill off the end of the board.
             */
            boolean spilledOffEnd = false;
            boolean everythingChecksOut = false;
            while (!spilledOffEnd && !everythingChecksOut) {
                if (pos > lastPos)
                    spilledOffEnd = true;
                else {
                    int curr = nextBoard.get(pos);
                    if ((curr > m_ceiling) ||
                        (curr == m_ceiling && lifted > 0)) {
                        /* Position is on the board, but the number of beads
                           will be over the limit if we set down lifted.  Lift
                           the extra beads and spill into the next slot.
                         */
                        lifted += nextBoard.get(pos) - m_ceiling;
                        nextBoard.set(pos, m_ceiling);
                        pos++;
                        if (pos > lastPos)
                            /* Position is off the board, so we spilled off
                               the end.
                             */
                            spilledOffEnd = true;
                        else {
                            /* We're on the board.  Set down lifted and check
                               for spillage again.  This is the only case that
                               causes the while-loop to keep checking for
                               spillage.
                             */
                            nextBoard.set(pos, nextBoard.get(pos) + lifted);
                            lifted = 0;
                        }
                    } else {
                        /* Position is on the board, and we don't exceed the
                           ceiling.
                         */
                        everythingChecksOut = true;
                    }
                }
            }
            if (spilledOffEnd) {
                lifted += nextBoard.get(lastPos);
                nextBoard.set(lastPos, 0);
                pos = findLastBead(nextBoard);
            } else
                return new MancalaBoard(nextBoard, m_ceiling);
        }
        return null;
    }

    /**
     * Creates a mutable deep copy of the internal immutable board representation.
     *
     * @return a mutable deep copy of the internal board.
     */
    private ArrayList<Integer> copyOfBoard() {
        ArrayList<Integer> newBoard = new ArrayList<Integer>();
        for (int i=0; i < m_board.size(); i++)
            newBoard.add(m_board.get(i));
        return newBoard;
    }

    /**
     * Finds the slot index of the bead furthest to the right.  Returns -1
     * if no bead is found.
     *
     * @param board the board to analyze
     * @return the index
     */
    private static int findLastBead(ArrayList<Integer> board) {
        int pos = board.size() - 1;
        while (board.get(pos) == 0) {
            pos--;
            if (pos < 0)
                return -1;
        }
        return pos;
    }

    @Override
    public String toString() {
        return m_board.toString();
    }
}
